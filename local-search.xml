<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>斐波那契数列的矩阵快速幂算法</title>
    <link href="/2025/07/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%A2%9D%E6%95%B0%E5%88%97%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <url>/2025/07/02/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%A2%9D%E6%95%B0%E5%88%97%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>我们在学习C++算法的时候会遇到一个十分基本的问题：</p><blockquote><p>我们都知道斐波那契数列：1，1，2，3，5，8，13，<spanclass="math inline">⋯</span>，现在已知第一个1记为第一项，第二个1记为第二项，2记为第三项，以此类推，现在我向里面输入一个<spanclass="math inline"><em>n</em></span>，请你告诉我数列中第<spanclass="math inline"><em>n</em></span>项的数值是多少？</p></blockquote><p>这个题很多人第一眼会感觉十分简单，确实，它确实不难，我们都十分熟悉斐波那契数列的递推公式：<spanclass="math inline"><em>a</em><sub><em>n</em></sub> = <em>a</em><sub><em>n</em> − 1</sub> + <em>a</em><sub><em>n</em> − 2</sub></span><spanclass="math inline">(<em>n</em> ≥ 2)</span></p><p>这天然就给了我们递归的土壤：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span> (n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span> (n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-built_in">Fibonacci</span>(n) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上系统学习过C++的同学都可以写出这段代码，但是这里存在一个非常明显的不足：时间复杂度太高，粗略估计：<spanclass="math inline"><em>O</em>(2<sup><em>n</em></sup>)</span>，在这个条件下，基本上<spanclass="math inline"><em>n</em> ≥ 50</span>的时候计算机就要算很久才能出结果的（我之前记得计算机每秒的运算次数大概在<spanclass="math inline">10<sup>9</sup></span>次左右，所以原本以为在40的时候差不多就要卡住了，但是实际操作下来的话50左右才会被卡住，只能说是计算能力又进步了，我out了​​）</p><p>当然，进一步想，我们的斐波那契数列计算太过于重复了，每一次递归，都要再计算一遍很多之前已经计算出结果的函数，那如果我们用一个数组，将我们计算过的数和相数都放在里面，不就大大简便了呢？所以这就是动态规划：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> *dp = <span class="hljs-keyword">new</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> [n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>cout &lt;&lt; dp[n] &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（我的码风不是特别规范，大家见谅，这里面的算是最基础的动态规划，比较简单，我就不详细说明了）</p><p>通过这个算法，我们已经将时间复杂度降到了<spanclass="math inline"><em>O</em>(<em>n</em>)</span>的级别，基本上在longlong数值范围内的斐波那契数列值我们都可以计算出来了（超出longlong数值范围的部分属于数字处理了，在这篇博客里面暂时不讨论，<del>当然不是笔者不会的原因</del>）</p><p>不过正经讲，在笔者做过的信息学竞赛题目中，这类结果一般是让你取模的，所以说更高效的算法也是有必要的。</p><p>在算法结构中，有一种十分巧妙的方法叫做快速幂。如果我们要计算<spanclass="math inline"><em>x</em><sup><em>n</em></sup></span>，这里面最为直接的方法就是将<spanclass="math inline"><em>n</em></span>个<spanclass="math inline"><em>x</em></span>相乘，时间复杂度为<spanclass="math inline"><em>O</em>(<em>n</em>)</span>，但这个方法可以进一步简化，将时间复杂度降到<spanclass="math inline"><em>O</em>(log<sub>2</sub><em>n</em>)</span>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x, n;<br>cin &gt;&gt; x &gt;&gt; n;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>)res *= x;<br>x = x * x;<br>n &gt;&gt; = <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; res &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法其实非常好理解，就是将<spanclass="math inline"><em>n</em></span>转换为二进制，每一次只取<spanclass="math inline"><em>n</em></span>的末位来看，如果是<spanclass="math inline">1</span>，那么就将结果乘上<spanclass="math inline"><em>x</em></span>，如果是<spanclass="math inline">0</span>，那就不用管，同时，由于数位不断地左移（注意，<spanclass="math inline"><em>n</em> &gt;  &gt;  = 1</span>是将<spanclass="math inline"><em>n</em></span>右移，但是从位数上来说，就是左移），<spanclass="math inline"><em>x</em></span>需要自增，也就是变为<spanclass="math inline"><em>x</em><sup>2</sup></span>。</p><p>这个算法的时间复杂度，就是只有<spanclass="math inline"><em>O</em>(log<sub>2</sub><em>n</em>)</span>。</p><p>我们知道了这个方法，对于我们解决这个问题有什么帮助呢？</p><p>对于斐波那契数列，特殊矩阵的幂可以计算出斐波那契额数列的结果：</p>$$<p>$$</p><p>从中我们可以很轻易地得到：</p><p><span class="math display">$$\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]^n=\left[\begin{matrix}a_{n+1}&amp;a_n\\a_n&amp;a_{n-1}\end{matrix}\\\right]$$</span></p><p>其中<spanclass="math inline"><em>a</em><sub><em>n</em></sub></span>是斐波那契数列中的第<spanclass="math inline"><em>n</em></span>项</p><p>其实通过这些铺垫，我们通过矩阵快速幂来解决斐波那契问题的答案已经呼之欲出了，最后的一道拦路虎就是如何运用C++来计算矩阵的乘法，这个问题我觉得没有单独拎出来讨论的必要（<del>绝对不是因为笔者懒了不想写了</del>,现在已经凌晨1：30了，好困）</p><p>接下来是完整的代码（幸好之前已经写过了，<del>可以早点睡觉</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;ll&gt; vec;<br><span class="hljs-keyword">typedef</span> vector&lt;vec&gt; mac;<span class="hljs-comment">//mac就是用来表示矩阵的</span><br><span class="hljs-comment">//计算矩阵的相乘</span><br><span class="hljs-function">mac <span class="hljs-title">calmartix</span><span class="hljs-params">(mac a,mac b)</span></span>&#123;<br><span class="hljs-function">mac <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>, vec(<span class="hljs-number">2</span>) )</span></span>;<span class="hljs-comment">//只需要一个2*2的矩阵就可以了</span><br><span class="hljs-type">int</span> cnt;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">2</span>; j++)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">2</span>;k++)<br>cnt += a[i][k] * b[k][j];<span class="hljs-comment">//矩阵的计算</span><br>ans[i][j] = cnt;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">//快速幂</span><br><span class="hljs-function">mac <span class="hljs-title">quickcal</span><span class="hljs-params">(mac a,ll n)</span></span>&#123;<br><span class="hljs-function">mac <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>, vec(<span class="hljs-number">2</span>))</span></span>;<br>res[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>res[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//这时候的res是一个单位矩阵</span><br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) res = <span class="hljs-built_in">calmartix</span>(res , a);<br>a = <span class="hljs-built_in">calmartix</span>(a , a);<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//矩阵的快速幂</span><br><span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-function">mac <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,vec(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">mac <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span>,vec(<span class="hljs-number">2</span>))</span></span>;<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//这里的a就是我们之前讨论的特殊矩阵</span><br>ans = <span class="hljs-built_in">quickcal</span>(a ,n);<br>cout &lt;&lt; ans[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">//这里你也可以cout &lt;&lt; ans[1][0] &lt;&lt; endl;都一样看你心情</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>矩阵的计算次数是一个常数，我们在考虑时间复杂度的时候可以忽略，这个算法的时间复杂度就是<spanclass="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em><sub>2</sub><em>n</em>)</span></p><p>有兴趣的读者可以自己动手亲自写一写~</p><p>（终于写完了，可以睡觉啦！！！！！）</p>]]></content>
    
    
    <categories>
      
      <category>算法题(C++)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>最优时间复杂度</tag>
      
      <tag>快速幂</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列求和</title>
    <link href="/2025/07/02/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/"/>
    <url>/2025/07/02/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="最大连续子序列求和">最大连续子序列求和</h2><p>题目：</p><blockquote><p>给你一个整数列，<spanclass="math inline"><em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, <em>A</em><sub>3</sub>, ⋯, <em>A</em><sub><em>n</em></sub></span>，在其中找到一个连续的子链<spanclass="math inline"><em>A</em><sub><em>i</em></sub>, <em>A</em><sub><em>i</em> + 1</sub>, ⋯, <em>A</em><sub><em>j</em></sub>(1 ≤ <em>i</em> ≤ <em>j</em> ≤ <em>N</em>)</span>使得<spanclass="math inline">$\sum_{k=i}^{j}A_k$</span>的值最大，如果所有的数都是负数，则规定最大连续子链和为<spanclass="math inline">0</span></p></blockquote><p>这个其实是非常简单的一道题，随着思维的深入，时间复杂度可以多次降低，比如说，我们肯定可以想到一个时间复杂度为<spanclass="math inline"><em>O</em>(<em>N</em><sup>3</sup>)</span>的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;start,<span class="hljs-type">int</span> &amp;end)</span></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; size; j++)&#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i;k &lt;= j; k++)<br>                count += A[k];<br>            <span class="hljs-keyword">if</span>(count &gt; result)&#123;<br>                result = count;<br>                start = i;<br>                end = j;<br>            &#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个想法比较简单，我就不写注释了。简单分析一下，这里面其实有一个十分浪费的地方，就是每次都需要重新计算<spanclass="math inline">$\sum_{k=i}^{j}A_k$</span>的值，这种做法实际上是没什么必要的，我们完全可以进行预处理，这样时间复杂度降到了<spanclass="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span>，这就是前缀和的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;start,<span class="hljs-type">int</span> &amp;end)</span></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>)&#123;<br>        start = <span class="hljs-number">0</span>;<br>        end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result, A[<span class="hljs-number">0</span>]);<span class="hljs-comment">//如果只有一个数，那么就不用想那么多，这个数是正数，就是这个正数，这个数是负数，就是0</span><br>    &#125;<br>    <span class="hljs-type">int</span> *sum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [size<span class="hljs-number">+1</span>];<br>    sum[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; size; i++)<br>        sum[i] = sum[i<span class="hljs-number">-1</span>] + A[i];<span class="hljs-comment">//前缀和，即sum[i]就是A[0]+A[1]+...+A[i]的值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; size; j++)&#123;<br>            <span class="hljs-keyword">if</span>(result &lt;= (sum[j] - sum[i]))&#123;<br>                start = i;<br>                end = j;<br>                result = (sum[j] - sum[i]);<span class="hljs-comment">//这样，我们只需要用sum[j] - sum[i]就可以表示从i到j中所有元素的和</span><br>            &#125; <br>&#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>笔者这边申明一下，如果返回结果是<spanclass="math inline">0</span>，那就不需要再打出来<code>start</code>和<code>end</code>的值了。具体实现可以写在主函数里，笔者这里就不再赘述了。还有就是<code>sum[j]-sum[i]</code>到底需不需要加括号，这个关于C++运算符号优先级的问题，笔者打算后面专门开一篇来介绍。</p><p>可能有人会对我说：</p><p>主播主播，你的方法确实很强，但是还是太吃时间复杂度了，有没有更简便的方法推荐呢？</p><p>有的兄弟有的</p><p>（理解一下笔者的精神状态）</p><p>好了，正经点，其实还有一种<spanclass="math inline"><em>O</em>(<em>n</em>)</span>的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;start,<span class="hljs-type">int</span> &amp;end)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    start = <span class="hljs-number">0</span>;<span class="hljs-comment">//把起点都初始化一下</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++)&#123;<span class="hljs-comment">//j往后移，计算这时候的子链和</span><br>        count += A[j];<br>        <span class="hljs-keyword">if</span>(count &gt; result)&#123;<span class="hljs-comment">//如果当下子链和比我之前的结果大，那么就将结果替换为当下的子链和</span><br>            result = count;<br>            start = i;<br>            end = j;<br>&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//重点：如果我当下的子链和是小于零的，那么这一段我直接抛掉，将我计算的起始点放到j+1的位置</span><br>            count = <span class="hljs-number">0</span>;<br>            i = j + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个方法，我写了一些备注，不过可能还是有读者没有看懂，我仔细来说一下：<code>i</code>是起点，是我当下计算子列的起始点，然后我去用<code>j</code>来遍历<code>A[]</code>这个数组，将<code>j</code>的结果累计到<code>count</code>中，每一次循环中，对<code>count</code>进行一次检查，如果<code>count</code>小于<code>0</code>，那么直接将<code>i</code>设为<code>j+1</code>，而<code>count</code>归零。</p><p>为什么这样做是正确的？因为任何一个子数列加上一个和小于0的子数列都会使合成的总数列和变小，那么既然如此，我就不计入和小于0的子数列，这一段，在我眼中，属于“亏本”的状态，不管它前置还是后置，我们都不会加上它，简单来说，就是<strong>如果一段连续数列的和是负数，它就不会是最大子序列的开头。</strong></p><p>如果从数学上理解了这点，这道题就迎刃而解了。</p>]]></content>
    
    
    <categories>
      
      <category>算法题(C++)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>最优时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在最前面</title>
    <link href="/2025/07/02/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/"/>
    <url>/2025/07/02/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎你来到牧丛的博客">欢迎你来到牧丛的博客！</h1><p>在正式浏览这个博客的主要内容之前，我希望你能够抽出几分钟的时间来阅读一下这篇文章，或许能够节约你的一部分时间。</p><p>其实笔者在2025年2月份期间，就开始着手搭建自己的博客，当时使用的是matery主题，当时也更新了一些文章，但是一直存在一些格式上不适配的现象，后来在朋友的推荐下选择了fluid的主题。但是交大大一下的课程堪称恐怖，笔者拼劲全力，实在没有办法在保证课内学习质量的情况下持续更新博客，无奈只能停更。现在已是暑假，笔者决定重整旗鼓，重新开始博客的更新。下面是我2025年年初写的前言（略有修改）：</p><p>首先，我想先简单介绍一下有关我博客名字的一些事情。在网址和Github那里，你可以看到我注册的名称是“MYCDherder”，而进入博客后的自我介绍中，会告诉你我的昵称叫“牧丛”，这是我个人习惯所导致的。我是个不怎么会起名字的人，我几乎所有的账户，倘若可以用中文表示，那就一律起名为“牧丛”，而若是需要英文，我一般就会使用“MYCD”。但是由于“MYCD”的名字过短，不能通过Github的名称审核，我只好将两个名字融合起来，“牧丛”没有直接对应的英文单词，我就取了其中的“牧”字，将其翻译为“herder”，“放牧的人”，两者一结合，问题就迎刃而解了。</p><p>再说说笔者，笔者目前是一名上海交通大学的本科生，就读于信息工程专业。在初高中的学习生活中，笔者一直算不上一个出色的学生，也常常被周围巨佬们的天才表现所震撼。在大学的生活中，笔者也往往比较迟钝，很多消息往往知道得比别人慢，产生了一定的信息差。像个人博客这种东西，也是几个月前，笔者发现一个高中同学已经创建了属于自己的博客时才了解到的。</p><p>当然，笔者创立这个博客，并不是为了盲目地跟风。笔者初入大学，对于大学的学习生活，依然没有能够找到一条稳定而高效的路径。显而易见，初高中以熟练度为主的应试方法必然不会符合大学的教育模式，单纯的高分也不是中国本科教育的目的。笔者建立这个博客，其实也是对自己本科学习方法的一种探索。当然，不同于毫无意义的胡乱尝试，创建并运营博客有着一些明显的好处：</p><p>第一，博客的运营需要持续的更新，持续的更新就需要持续的学习与思考，对于自己博客的运营其实也是一种自我的督促。</p><p>第二，更新博客的过程其实也是“费曼学习法”，博客更新的内容是公开的，实质上就是将笔者所学的知识用自己的语言，以通俗易懂的方式教授给别人。在这个过程中，笔者对于知识的理解也会更加透彻。</p><p>当然，创立的博客的好处当然不止这些，但限于篇幅原因，笔者不再继续探讨。其实，笔者更多是想把这个博客做成一个类似于学习笔记的东西，当然，这并不意味着笔者会呆板地去照抄教材。笔者希望的，是能够在这些基础学科中找到一些大家忽略的细节，进行一些深度的思考。</p><p>除了单纯的巩固细节之外，笔者还希望能够对于一些现有的模型进行自己的思考和阐释。当然，这些思考不一定是笔者率先提出来的，笔者所表述出来的语言也不一定精准，肯定会出现许多的瑕疵，但是笔者认为这个过程对于一个求学者来说是必要的。</p><p>在这个过程中，笔者可能会有一些想到一半就无法继续下去的想法，到时候可能会单独开一个列表，欢迎大家和笔者一起思考和讨论。</p><p>最后，笔者第一次创建并且尝试运营博客，可能会出现很多的错误和疏漏，如果读者愿意反馈给我，笔者将不胜感激。</p><p>最后的最后，非常感谢大家能够读完这篇文章，愿我们一起学习，一起进步！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
