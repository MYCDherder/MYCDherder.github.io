<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性表整理</title>
    <link href="/2025/07/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%95%B4%E7%90%86/"/>
    <url>/2025/07/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表">线性表</h1><h2 id="线性表的基础">线性表的基础</h2><p>线性表的之间定义我就不再多说了，直接来看一下它的基本运算：</p><p>（1）创建一个空的线性表（create）（2）删除数据表中的所有线性结构（clear） （3）求线性表的长度（length）（4）在第<code>i</code>个位置插图一个元素（insert）（5）删除第<code>i</code>个位置的元素（remove）（6）搜索元素，检查某个元素<code>x</code>在线性表中是否出现，并返回<code>x</code>的位置（search）（7）返回线性表中第<code>i</code>个数据元素的值（visit）（8）按序访问线性表的每一个数据元素（traverse）</p><p>我们可以直接产生面向对象的程序设计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<span class="hljs-comment">//这里面我使用了一个模板，但是实际上不一定需要，只是为了更具有普适性</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">linearlist</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//在类的成员函数里面能加const的都加上const</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<span class="hljs-comment">//遇到负责类型作为参数的时候，就直接const + 复杂类型 + &amp;这样最节省时间和空间</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> T <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>b <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">list</span>()&#123;&#125;;<span class="hljs-comment">//为什么这个地方不再构建纯虚函数，我在后面应该会单开一篇来讲纯虚函数的事</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在上面的代码里除了析构函数以外，其他基本上都是纯虚函数，这样相当于勒令衍生类解决这些问题，这样一个基本的线性表的就构建好了，我们为什么在上面只是设置成员函数，但是没有去设置数据成员？因为线性表有多种表示方式，既可以是顺序表，也可以是链表，链表又可以分为单双链表，顺序表也有多种表达方式，不同的表示方式我们要设置的私有数据成员也不同，我们只能够放到衍生类里面去实现。</p><h2 id="顺序表类">顺序表类</h2><h3 id="顺序列表基础申明">顺序列表基础申明</h3><p>顺序实现是我们存放数据最自然的一种方式，基本上所有事务我要把它归类，首先都是这么干的，它的基础逻辑就是数组，不过在C++中，数组确实不太好用（主要是在申明的时候就要给定最大容量，这对于经常要使用变量的我们来说还是十分复杂的），但是通过指针，我们就可以很清爽地规避掉这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">seqlist</span>: <span class="hljs-keyword">public</span> linearlist&lt;T&gt;&#123; <span class="hljs-comment">//通过public的方式来继承linearlist</span><br>    <span class="hljs-keyword">private</span>:<br>T *data;<br>    <span class="hljs-type">int</span> curlength;<span class="hljs-comment">//当下长度</span><br>    <span class="hljs-type">int</span> maxsize;<span class="hljs-comment">//最大长度</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doublespace</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//私有的成员函数，将空间双倍，为什么将他设置为私有？因为这个基本上只有在成员函数里面才会运用到，不需要对用户开放，当然，如果你要坚持写在public里面，也没有问题</span><br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">seqlist</span>(<span class="hljs-type">int</span> startsize);<span class="hljs-comment">//构造函数</span><br>    ~<span class="hljs-built_in">seqlist</span>();<span class="hljs-comment">//析构函数，来清除动态数组的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//来清除其他东西的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> T &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">T <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>基本上还是跟上面一样的说明，但是这次就不能再打太极了，必须解决，不过一个习惯就是不要放在类里面解决（除非真的很短）</p><h3id="析构函数clearlengthvisittraverse函数的实现">析构函数，clear，length，visit，traverse函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//~seqlist的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>seqlist&lt;T&gt;::~<span class="hljs-built_in">seqlist</span>()&#123;<br>    <span class="hljs-keyword">delete</span> [] data;<br>&#125;<br><span class="hljs-comment">//clear的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqlist&lt;T&gt;::<span class="hljs-built_in">clear</span>()&#123;<br>    curlength = <span class="hljs-number">0</span>;<br>    maxsize = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//length的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> seqlist&lt;T&gt;::<span class="hljs-built_in">length</span>()<span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">return</span> curlength;<br>&#125;<br><span class="hljs-comment">//visit的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T seqlist&lt;T&gt;::<span class="hljs-built_in">visit</span>(<span class="hljs-type">int</span> i)<span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">return</span> data[i];<br>&#125;<br><span class="hljs-comment">//traverse的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqlist&lt;T&gt;::<span class="hljs-built_in">traverse</span>()<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= curlength; i++)<br>        cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>   cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是最简单的几个功能的实现，基本上所有学习过C++的读者都可以轻松自己编写，除了<code>traverse</code>函数的时间复杂度是<spanclass="math inline"><em>O</em>(<em>n</em>)</span>，其他的时间复杂度都是<spanclass="math inline"><em>O</em>(1)</span>，接下来几个比较能够体现顺序类列表的特点，我分开来列：</p><h3 id="构造函数的实现">构造函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//构造函数的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>seqlist&lt;T&gt;::<span class="hljs-built_in">seqlist</span>(<span class="hljs-type">int</span> startsize)&#123;<br>    data = <span class="hljs-keyword">new</span> T [startsize];<br>    maxsize = startsize;<br>    currentlength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个其实也非常简单（或许我应该把它列在上面的，算了，<del>懒得动</del>）</p><h3 id="search的实现">search的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//search的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> seqlist&lt;T&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> T &amp;x)<span class="hljs-type">const</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; curlength &amp;&amp; data[i] != x; i++);<br>    <span class="hljs-keyword">return</span> ((i == curlength)?<span class="hljs-number">-1</span>:i);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实讲真的，基本上所有人都能看得出来这块挺麻烦的，但是搜索就是这样，除非储存下标，不然就是需要遍历，时间复杂度就是<spanclass="math inline"><em>O</em>(<em>n</em>)</span>级别的。</p><h3id="doublespace和search函数的实现">doublespace和search函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//doublespace和search函数的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqlist&lt;T&gt;::<span class="hljs-built_in">doublespace</span>()&#123;<br>    T *tmp = data;<br>    maxsize *= <span class="hljs-number">2</span>;<br>    data = <span class="hljs-keyword">new</span> T [maxsize];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; curlength; i++)<br>        data[i] = tmp[i];<br>    <span class="hljs-keyword">delete</span> [] tmp;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqlist&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i,<span class="hljs-type">const</span> T &amp;x)&#123;<br><span class="hljs-keyword">if</span>(curlength == maxsize)<br><span class="hljs-built_in">doublespace</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; curlength; j++)<br>        data[j + <span class="hljs-number">1</span>] = data[j];<br>    data[i] = x;<br>    curlength++;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上十分明显了，很简单就是我要插入在第<code>i</code>的位置，那么我把自从第<code>i</code>往后的每一位都向后挪一个位置，再把第<code>i</code>位变成我要的<code>x</code>这样子就完成了，这里就是顺序表和链表最大的不同，不过两者基本上都是<spanclass="math inline"><em>O</em>(<em>n</em>)</span>的时间复杂度，因为顺序表知道下标但是挪动需要花一定的时间，而链表是挪动不用花时间但是不知道下表（但是实际上可以解决）</p><h3 id="remove函数的实现">remove函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//remove的实现</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> seqlist&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; curlength; j++)<br>        data[j] = data[j + <span class="hljs-number">1</span>];<br>    curlength--;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表就这么多内容了，基本上没有什么例外，确实比较简单，链表在<code>move</code>函数那边比较具有迷惑性，需要好好解释一下的我们接下来探讨</p><h2 id="单链表">单链表</h2><h3 id="单链表类的定义">单链表类的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">slinklist</span>: <span class="hljs-keyword">public</span> linearlist&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>            T data;<br>            node *next;<span class="hljs-comment">//这两个是链表的基本元素</span><br>            <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> T &amp;x, node *n = <span class="hljs-literal">NULL</span>)&#123;data = x; next = n;&#125;<span class="hljs-comment">//这里面是node的构造函数</span><br>            <span class="hljs-built_in">node</span>():<span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<span class="hljs-comment">//这个是没有初始化的时候的构造函数，将next指针指向NULL是避免错误的一个非常好的做法</span><br>            ~<span class="hljs-built_in">node</span>()&#123;&#125;<br>        &#125;;<br>    node *head;<span class="hljs-comment">//这个是头节点</span><br>    <span class="hljs-type">int</span> curlength;<span class="hljs-comment">//这个是当下的长度</span><br>    <span class="hljs-function">node *<span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">slinklist</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br>    ~<span class="hljs-built_in">slinklist</span>()&#123;<span class="hljs-built_in">clear</span>();<span class="hljs-keyword">delete</span> head;&#125;<span class="hljs-comment">//clear就是将所有除头节点以外的节点全部清除</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> curlength&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">const</span> T &amp;x)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;x)</span></span><br><span class="hljs-function">             T <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里里面的定义基本上都跟上面一样，不过这里需要注意的就是<code>node</code>作为结构体，也具有构造函数和析构函数，形式跟类差不多</p><h3 id="move函数的实现">move函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//move函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">typename</span> slinklist&lt;T&gt;::node *slinklist&lt;T&gt;::<span class="hljs-built_in">move</span>(<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>&#123;<span class="hljs-comment">//这个地方需要申明的就是typename是一个可有可无的量，其本质就是对编译器申明这里是一个变量名，可能有些不太先进的编译器没有办法识别出来</span><br>    node *p = head;<br>    <span class="hljs-keyword">while</span>(i-- &gt;= <span class="hljs-number">0</span>)p = p -&gt; next;<span class="hljs-comment">//这里面i-- &gt;= 0总共会循环i + 1次</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面为什么是<code>i + 1</code>次循环？而不是<code>i</code>我们的头节点并不是我们的第0个节点，我们要从头节点移动到第0个节点需要移动1次，第一个节点需要2次……以此类推，你要到第<code>i</code>个节点，就需要<code>i + 1</code>次，那既然如此，我们为什么不直接去除掉<code>head</code>节点，来考虑剩下来的问题？这个问题我们下文会考虑</p><h3 id="构造函数的实现-1">构造函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//slinklist的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>slinklist&lt;T&gt;::<span class="hljs-built_in">slinklist</span>()&#123;<br>head = <span class="hljs-keyword">new</span> node;<br>    curlength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>非常简单，没有什么好讲的（<del>所以你干嘛写它呢？</del>）</p><h3 id="clear函数的实现">clear函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//clear函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> slinklist &lt;T&gt; ::<span class="hljs-built_in">clear</span>()&#123;<br>node *p = head-&gt;next ,*q;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>q = p-&gt;next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<span class="hljs-comment">//删除，然后移动到下一个节点</span><br>    &#125;<br>    curlength = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也是非常的简单，不多说了</p><h3 id="insert和remove函数的实现">insert和remove函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//insert函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> slinklist&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> T &amp;x)&#123;<br>node *pos;<br>    pos = <span class="hljs-built_in">move</span>(i - <span class="hljs-number">1</span>);<br>    pos-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x, pos-&gt;next);<span class="hljs-comment">//这里使用了我在定义里面写的node的构造函数</span><br>    curlength++;<br>&#125;<br><span class="hljs-comment">//remove函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> slinklist&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)&#123;<br>node *pos, *delp;<br>    pos = <span class="hljs-built_in">move</span>(i - <span class="hljs-number">1</span>);<br>    delp = pos-&gt;next;<br>    pos-&gt;next = delp-&gt;next;<br>    <span class="hljs-keyword">delete</span> delp;<br>    curlength--;<br>&#125;<br></code></pre></td></tr></table></figure><p>终于来了点有意思的东西了，第一个问题：为什么<code>move</code>函数的参数是<code>i - 1</code>?而不是<code>i</code>呢？我们要去除第<code>i</code>个节点，自然就是要将<code>i - 1</code>和<code>i + 1</code>链接起来，所以实际上，我们将<code>pos</code>移到<code>i - 1</code>的位置是便于操作的，因为我们这边是单链表，你找你的下家容易，但是你去找上家比较的困难</p><p>另外再说，为什么我们需要将<code>node</code>后面写上<code>x, pos-&gt;next</code>的参数，可以参考我在定义里面写的<code>node(const T &amp;x, node *n = NULL)&#123;data = x; next = n;&#125;</code>我们将这里面的<code>x</code>变为一个新的节点的<code>data</code>然后将原来<code>pos-&gt;next</code>变作这个新节点的<code>next</code>，最后将<code>post-&gt;next</code>改为这个新节点的地址，如果我们不要求代码的美观度这么高，我们可以写得明显一些：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">node *tmp = <span class="hljs-keyword">new</span> node;<br>tmp-&gt;data = x;<br>tmp-&gt;next = pos-&gt;next;<br>pos-&gt;next = tmp;<br></code></pre></td></tr></table></figure><p>上面这四行代码可以达到同样的效果</p><p>在<code>remove</code>函数的实现中，注意<code>delp</code>函数的使用，因为<code>delp</code>函数其实是记下来给用来释放空间的，不然会产生内存泄漏。</p><h3id="searchvisittraverse函数的实现">search，visit，traverse函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//search函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> slinklist&lt;T&gt;::<span class="hljs-built_in">search</span>(<span class="hljs-type">const</span> T &amp;x)<span class="hljs-type">const</span>&#123;<br>node *p = head-&gt;next;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;data != x)&#123;<br>p = p-&gt;next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果p是到NULL的时候停下来的说明没有找到x，x不存在在顺序链表里</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-comment">//visit函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T slinklist&lt;T&gt;::<span class="hljs-built_in">visit</span>(<span class="hljs-type">int</span> i)<span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">move</span>(i)-&gt;data;<br>&#125;<br><span class="hljs-comment">//traverse函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> slinklist&lt;T&gt;::<span class="hljs-built_in">traverse</span>()<span class="hljs-type">const</span>&#123;<br>node *p = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这三个函数还是十分简单的，基本上就是遍历了，没有什么太过困难的。</p><h3 id="无头结点的函数实现">无头结点的函数实现</h3><p>但是</p><p>你觉得，这就结束了吗？</p><p><strong>不！</strong></p><p>我们还要尝试无头结点的情况下面的单链表，判断为什么拥有头节点是一件更好的事情，我们来尝试一下无头结点情况下的<code>insert</code>和<code>remove</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//无头结点下的insert函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> slinklist&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> T &amp;x)&#123;<br><span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>p = head;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x,p);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        p = <span class="hljs-built_in">move</span>(i - <span class="hljs-number">2</span>);<br>        p-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>(x,p-&gt;next);<span class="hljs-comment">//其实在i &gt; 0的情况下其实差不多，没有什么太大的区别，就是只能移动i - 2位了</span><br>    &#125;<br>    curlength++;<br>&#125;<br><span class="hljs-comment">//无头结点下的remove函数的实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> slinklist&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">int</span> i)&#123;<br>node *pos, *delp;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>        delp = head;<br>        head = delp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>p = <span class="hljs-built_in">move</span>(i - <span class="hljs-number">2</span>);<br>        delp = p-&gt;next;<br>        p-&gt;next = delp-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> delp;<br>    curlength--;<br>&#125;<br></code></pre></td></tr></table></figure><p>明显可以看出来复杂得多了，因为我们需要对于有<code>i == 0</code>的情况进行专门的判断，我建议有精力的读者可以自己用笔来画画图，来理解一下为什么这里面<code>i == 0</code>需要专门判断，笔者本来也想写一写然后贴图片上去的，但是作业还没有写完（悲），就不能继续写了</p><h2 id="总结">总结</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构知识整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>数组</tag>
      
      <tag>更新中</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一道分块处理的题目</title>
    <link href="/2025/07/03/%E5%88%86%E5%9D%97%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/"/>
    <url>/2025/07/03/%E5%88%86%E5%9D%97%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我们来看一下这个题目：</p><p>JokerXue想要租房子，而他的心上人对数字十分敏感。他发现，对于一间租金为<em>p</em>元/月的房子，他的心上人的心理不悦度是这样计算的：</p><ol type="1"><li>首先将 <em>p</em> 看做一个由数字组成的字符串（不带前导 0）；</li><li>然后，如果 <em>p</em> 的最后一个字符是0，就去掉它。重复这一过程，直到 <em>p</em> 的最后一个字符不是 0；</li><li>记 <em>p</em> 的长度为 a<em>，如果此时 p</em> 的最后一位是5，则不悦度为 2<em>a</em>−1；否则为 2<em>a</em>。</li></ol><p>例如，850 代表的不悦度为 3，而 880 则为 4，9999 为 8。</p><p>JokerXue想要在<em>T</em>个不同的地区租房子，在每个地区他都有一个租金的心理预期[L, R]，现在他想要知道在这些地区能够使得心上人<strong>心理不悦度最低并且租金较低</strong>的方案。</p><p>JokerXue要去准备他的“万兽之王”演唱会，所以请聪明的你帮忙进行最优解的计算。</p><h3 id="输入格式">输入格式</h3><p>输入文件的第一行包含一个正整数 <em>T</em>，表示JokerXue想要租房子的地区的数量。</p><p>接下来的T<em>行，每行包含两个空格分隔的正整数L</em>,<em>R</em>，表示他的租金心理预期。</p><h3 id="输出格式">输出格式</h3><p>对于每个地区，在单独的一行内输出能使心上人的心理不悦度最低的租金值。如果结果不唯一，则输出<strong>最小</strong>的那个。</p><h3 id="样例">样例</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">998 </span><span class="hljs-number">1002</span><br><span class="hljs-symbol">998 </span><span class="hljs-number">2002</span><br><span class="hljs-symbol">4000 </span><span class="hljs-number">6000</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1000</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><h3 id="数据范围">数据范围</h3><ul><li>对于 20%的数据，<em>L</em>,<em>R</em>≤2000；</li><li>对于 100% 的数据，<em>T</em>≤100，1 ≤<em>L</em>≤ <em>R</em> ≤1e9。</li></ul><p>这是我们学校ACMOJ上面的一道题，以下是题目链接：</p><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/2618">租购 ·ACMOJ</a></p><p>我们来分析以下这个题目，我们根据数据规模可以很轻松地判断出这里不能够直接遍历，因为时间不够，那么从常用的角度来说，就是剩下了两种时间复杂度<spanclass="math inline">$O(\log n)和O(\sqrtn)$</span>（常数级的时间复杂度我们就不考虑了，其实笔者的一个朋友有相关的想法，但是没有最后实践成功，后续笔者可能会继续想一想这个问题），在这里面我们不难发现，对数级的时间复杂度固然更为简便，但是似乎没有合适的算法来实现，我们自然而然就会往根号级的算法去想，而最为直接的根号级算法，就是分块处理：</p><p>我们来思考一下，其实我们先明确一点，我们将<em>p</em>所有计入不悦度运算的位数称为<strong>有效位</strong>，那么我们可以很明显地看出，有效位是越少越好的，而且有效位少的优先级应该比末尾是5的有限级更高，因为末尾是5，结果只是在原有基础上-1，而如果有效位能够少一个，那么不悦度的结果可以-2</p><p>那我们达成共识，现在可行的范围内找有效位尽可能少的，然后在有效位已经最少的情况下，看看有效位的末尾能不能取到5。</p><p>这是我们处理的原则，那么接下来如何分块呢？</p><p>我们先想一下<code>r - l</code>的范围，如果<code>r - l</code>小于<em>1e5</em>，那么我们其实可以直接范围内的数进行遍历，计算出每一个数的不悦度，这样就比较，取最小，最后计算机的计算次数差不过是在<em>1e6</em>这个级别的，不会有超时的情况。</p><p>那如果<code>r - l</code>大于<em>1e5</em>呢？那是不是<strong>在区间之间，至少存在一个后五位都是0的数</strong>，那我们实际上，后5位存在非零数位的数，必然不会符合我们的最优要求，所以我们只要将<code>r</code>和<code>l</code>都除以<em>1e5</em>，然后再在新得到的区间里面遍历就可以了，这个算法的复杂度计算次数大概是<em>1e9/1e5=1e4</em>这个级别的，算上我们的操作数，至多也就在<em>1e5</em>级别，比我们上一种情况的遍历还要更快速一些。</p><p>OK，理论可行，接下来就是具体实现了，细节方面还有很多要考虑的，之前笔者在交这道题的时候好多次都WA了，就是因为有些细节没有考虑清楚。</p><p>我们先来设计一个直接计算不悦度的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">byd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br>x /= <span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(x%<span class="hljs-number">10</span> == <span class="hljs-number">5</span>)<br>flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>)&#123;<br>x /= <span class="hljs-number">10</span>;<br>cnt++;<br>&#125;<br>cnt = cnt * <span class="hljs-number">2</span> - flag;<span class="hljs-comment">//flag为true，那么相当于多尾数是5，在原有基础上-1</span><br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数名我的设计理念就是“不悦度”汉语拼音的缩写（bu）（yue）（du），请不要产生无端联想~</p><p>我们再来设计一个<code>solve()</code>函数，直接解决从<code>l</code>到<code>r</code>的范围问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l,<span class="hljs-type">long</span> <span class="hljs-type">long</span> r)</span></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans1 = l;<br><span class="hljs-type">int</span> ans2 = <span class="hljs-built_in">byd</span>(l);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = l;i &lt;= r; i++)&#123;<br><span class="hljs-type">int</span> tmp = <span class="hljs-built_in">byd</span>(i);<br><span class="hljs-keyword">if</span>(tmp &lt; ans2)&#123;<br>ans1 = i;<br>ans2 = tmp;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans1;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上就是最简单的判断，没有什么好说的</p><p>我们再来写一下<code>main()</code>函数，记住其中有很多非常容易错的细节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> N = <span class="hljs-number">1e5</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x = r - l;<br><span class="hljs-keyword">if</span>(x &lt;= N)<br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l,r) &lt;&lt; endl;<span class="hljs-comment">//如果小于1e5，那么直接丢给solve()</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(l &lt; N)&#123;<span class="hljs-comment">//这里就是第一种特殊情况，如果l比1e5小，那么l就不能直接处理，需要进行判断</span><br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">5</span> * N)<span class="hljs-comment">//因为你的x是大于1e5的，所以r至少是一个五位数，五位数中不悦度最低的就是5*1e5，但我们不能确保r的范围能够到达那个程度，我们还要基于此做一次判断</span><br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l, <span class="hljs-number">5</span> * N) &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l, r) &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(l % N == <span class="hljs-number">0</span>)<span class="hljs-comment">//这里需要记住，在/1e5之后，我们的l应该是向上取整的，r是向下取整的，所以l还要对于边界判断</span><br>l /= N;<br><span class="hljs-keyword">else</span>&#123;<br>l /= N;<br>l++;<br>&#125;<br>r /= N;<span class="hljs-comment">//r是向下取整，符合C++中的除号运算符</span><br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l,r) * N &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将三段代码合并到一块，就可以得到AC的结果（笔者实测过）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> N = <span class="hljs-number">1e5</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">byd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br>x /= <span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(x%<span class="hljs-number">10</span> == <span class="hljs-number">5</span>)<br>flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>)&#123;<br>x /= <span class="hljs-number">10</span>;<br>cnt++;<br>&#125;<br>cnt = cnt * <span class="hljs-number">2</span> - flag;<span class="hljs-comment">//flag为true，那么相当于多尾数是5，在原有基础上-1</span><br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> l,<span class="hljs-type">long</span> <span class="hljs-type">long</span> r)</span></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans1 = l;<br><span class="hljs-type">int</span> ans2 = <span class="hljs-built_in">byd</span>(l);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = l;i &lt;= r; i++)&#123;<br><span class="hljs-type">int</span> tmp = <span class="hljs-built_in">byd</span>(i);<br><span class="hljs-keyword">if</span>(tmp &lt; ans2)&#123;<br>ans1 = i;<br>ans2 = tmp;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x = r - l;<br><span class="hljs-keyword">if</span>(x &lt;= N)<br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l,r) &lt;&lt; endl;<span class="hljs-comment">//如果小于1e5，那么直接丢给solve()</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(l &lt; N)&#123;<span class="hljs-comment">//这里就是第一种特殊情况，如果l比1e5小，那么l就不能直接处理，需要进行判断</span><br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-number">5</span> * N)<span class="hljs-comment">//因为你的x是大于1e5的，所以r至少是一个五位数，五位数中不悦度最低的就是5*1e5，但我们不能确保r的范围能够到达那个程度，我们还要基于此做一次判断</span><br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l, <span class="hljs-number">5</span> * N) &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l, r) &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">if</span>(l % N == <span class="hljs-number">0</span>)<span class="hljs-comment">//这里需要记住，在/1e5之后，我们的l应该是向上取整的，r是向下取整的，所以l还要对于边界判断</span><br>l /= N;<br><span class="hljs-keyword">else</span>&#123;<br>l /= N;<br>l++;<br>&#125;<br>r /= N;<span class="hljs-comment">//r是向下取整，符合C++中的除号运算符</span><br>cout &lt;&lt; <span class="hljs-built_in">solve</span>(l,r) * N &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后来笔者与舍友讨论，应该还会存在常数级算法的可能，但是笔者没有能够实现，如果有读者愿意和笔者交流常数级算法的可能性，笔者将不胜感激。</p><p>感谢 <span class="citation"data-cites="Geniustanker">@Geniustanker</span>与笔者的讨论，这个题目也是他提供给笔者的。</p>]]></content>
    
    
    <categories>
      
      <category>算法题(C++)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分块算法</tag>
      
      <tag>时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列的矩阵快速幂算法</title>
    <link href="/2025/07/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%A2%9D%E6%95%B0%E5%88%97%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <url>/2025/07/03/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%A2%9D%E6%95%B0%E5%88%97%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>我们在学习C++算法的时候会遇到一个十分基本的问题：</p><blockquote><p>我们都知道斐波那契数列：1，1，2，3，5，8，13，<spanclass="math inline">⋯</span>，现在已知第一个1记为第一项，第二个1记为第二项，2记为第三项，以此类推，现在我向里面输入一个<spanclass="math inline"><em>n</em></span>，请你告诉我数列中第<spanclass="math inline"><em>n</em></span>项的数值是多少？</p></blockquote><p>这个题很多人第一眼会感觉十分简单，确实，它确实不难，我们都十分熟悉斐波那契数列的递推公式：<spanclass="math inline"><em>a</em><sub><em>n</em></sub> = <em>a</em><sub><em>n</em> − 1</sub> + <em>a</em><sub><em>n</em> − 2</sub></span><spanclass="math inline">(<em>n</em> ≥ 2)</span></p><p>这天然就给了我们递归的土壤：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span> (n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span> (n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-built_in">Fibonacci</span>(n) &lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上系统学习过C++的同学都可以写出这段代码，但是这里存在一个非常明显的不足：时间复杂度太高，粗略估计：<spanclass="math inline"><em>O</em>(2<sup><em>n</em></sup>)</span>，在这个条件下，基本上<spanclass="math inline"><em>n</em> ≥ 50</span>的时候计算机就要算很久才能出结果的（我之前记得计算机每秒的运算次数大概在<spanclass="math inline">10<sup>9</sup></span>次左右，所以原本以为在40的时候差不多就要卡住了，但是实际操作下来的话50左右才会被卡住，只能说是计算能力又进步了，我out了​​）</p><p>当然，进一步想，我们的斐波那契数列计算太过于重复了，每一次递归，都要再计算一遍很多之前已经计算出结果的函数，那如果我们用一个数组，将我们计算过的数和相数都放在里面，不就大大简便了呢？所以这就是动态规划：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> *dp = <span class="hljs-keyword">new</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> [n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>cout &lt;&lt; dp[n] &lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（我的码风不是特别规范，大家见谅，这里面的算是最基础的动态规划，比较简单，我就不详细说明了）</p><p>通过这个算法，我们已经将时间复杂度降到了<spanclass="math inline"><em>O</em>(<em>n</em>)</span>的级别，基本上在longlong数值范围内的斐波那契数列值我们都可以计算出来了（超出longlong数值范围的部分属于数字处理了，在这篇博客里面暂时不讨论，<del>当然不是笔者不会的原因</del>）</p><p>不过正经讲，在笔者做过的信息学竞赛题目中，这类结果一般是让你取模的，所以说更高效的算法也是有必要的。</p><p>在算法结构中，有一种十分巧妙的方法叫做快速幂。如果我们要计算<spanclass="math inline"><em>x</em><sup><em>n</em></sup></span>，这里面最为直接的方法就是将<spanclass="math inline"><em>n</em></span>个<spanclass="math inline"><em>x</em></span>相乘，时间复杂度为<spanclass="math inline"><em>O</em>(<em>n</em>)</span>，但这个方法可以进一步简化，将时间复杂度降到<spanclass="math inline"><em>O</em>(log<sub>2</sub><em>n</em>)</span>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x, n;<br>cin &gt;&gt; x &gt;&gt; n;<br><span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>)res *= x;<br>x = x * x;<br>n &gt;&gt; = <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; res &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法其实非常好理解，就是将<spanclass="math inline"><em>n</em></span>转换为二进制，每一次只取<spanclass="math inline"><em>n</em></span>的末位来看，如果是<spanclass="math inline">1</span>，那么就将结果乘上<spanclass="math inline"><em>x</em></span>，如果是<spanclass="math inline">0</span>，那就不用管，同时，由于数位不断地左移（注意，<spanclass="math inline"><em>n</em> &gt;  &gt;  = 1</span>是将<spanclass="math inline"><em>n</em></span>右移，但是从位数上来说，就是左移），<spanclass="math inline"><em>x</em></span>需要自增，也就是变为<spanclass="math inline"><em>x</em><sup>2</sup></span>。</p><p>这个算法的时间复杂度，就是只有<spanclass="math inline"><em>O</em>(log<sub>2</sub><em>n</em>)</span>。</p><p>我们知道了这个方法，对于我们解决这个问题有什么帮助呢？</p><p>对于斐波那契数列，特殊矩阵的幂可以计算出斐波那契额数列的结果：</p><p><span class="math display">$$\begin{align*} \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} &amp;=\begin{bmatrix} 2 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \\ \begin{bmatrix}2 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} 1 &amp; 1 \\ 1&amp; 0 \end{bmatrix} &amp;= \begin{bmatrix} 3 &amp; 2 \\ 2 &amp; 1\end{bmatrix} \\ \begin{bmatrix} 3 &amp; 2 \\ 2 &amp; 1 \end{bmatrix}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} &amp;=\begin{bmatrix} 5 &amp; 3 \\ 3 &amp; 2 \end{bmatrix}\end{align*}$$</span></p><p><span class="math display">$$\begin{matrix}\vdots \\\end{matrix}$$</span></p><p><span class="math display">$$\begin{align*}\begin{bmatrix} a_n &amp; a_{n-1} \\ a_{n-1} &amp; a_{n-2}\end{bmatrix} \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}&amp;= \begin{bmatrix} a_n + a_{n-1} &amp; a_n \\ a_{n-1} + a_{n-2}&amp; a_{n-1} \end{bmatrix} = \begin{bmatrix} a_{n+1} &amp; a_n \\ a_n&amp; a_{n-1} \end{bmatrix} \end{align*}$$</span></p><p>从中我们可以很轻易地得到： <span class="math display">$$\left[\begin{matrix}1&amp;1\\1&amp;0\end{matrix}\right]^n=\left[\begin{matrix}a_{n+1}&amp;a_n\\a_n&amp;a_{n-1}\end{matrix}\\\right]$$</span></p><p>其中<spanclass="math inline"><em>a</em><sub><em>n</em></sub></span>是斐波那契数列中的第<spanclass="math inline"><em>n</em></span>项</p><p>其实通过这些铺垫，我们通过矩阵快速幂来解决斐波那契问题的答案已经呼之欲出了，最后的一道拦路虎就是如何运用C++来计算矩阵的乘法，这个问题我觉得没有单独拎出来讨论的必要（<del>绝对不是因为笔者懒了不想写了</del>,现在已经凌晨1：30了，好困）</p><p>接下来是完整的代码（幸好之前已经写过了，<del>可以早点睡觉</del>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> vector&lt;ll&gt; vec;<br><span class="hljs-keyword">typedef</span> vector&lt;vec&gt; mac;<span class="hljs-comment">//mac就是用来表示矩阵的</span><br><span class="hljs-comment">//计算矩阵的相乘</span><br><span class="hljs-function">mac <span class="hljs-title">calmartix</span><span class="hljs-params">(mac a,mac b)</span></span>&#123;<br><span class="hljs-function">mac <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>, vec(<span class="hljs-number">2</span>) )</span></span>;<span class="hljs-comment">//只需要一个2*2的矩阵就可以了</span><br><span class="hljs-type">int</span> cnt;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span>; i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">2</span>; j++)&#123;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">2</span>;k++)<br>cnt += a[i][k] * b[k][j];<span class="hljs-comment">//矩阵的计算</span><br>ans[i][j] = cnt;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">//快速幂</span><br><span class="hljs-function">mac <span class="hljs-title">quickcal</span><span class="hljs-params">(mac a,ll n)</span></span>&#123;<br><span class="hljs-function">mac <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>, vec(<span class="hljs-number">2</span>))</span></span>;<br>res[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>res[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>res[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//这时候的res是一个单位矩阵</span><br><span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) res = <span class="hljs-built_in">calmartix</span>(res , a);<br>a = <span class="hljs-built_in">calmartix</span>(a , a);<br>n &gt;&gt;= <span class="hljs-number">1</span>;<br>&#125;<span class="hljs-comment">//矩阵的快速幂</span><br><span class="hljs-keyword">return</span> res;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-function">mac <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,vec(<span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-function">mac <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span>,vec(<span class="hljs-number">2</span>))</span></span>;<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//这里的a就是我们之前讨论的特殊矩阵</span><br>ans = <span class="hljs-built_in">quickcal</span>(a ,n);<br>cout &lt;&lt; ans[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;&lt; endl; <span class="hljs-comment">//这里你也可以cout &lt;&lt; ans[1][0] &lt;&lt; endl;都一样看你心情</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>矩阵的计算次数是一个常数，我们在考虑时间复杂度的时候可以忽略，这个算法的时间复杂度就是<spanclass="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em><sub>2</sub><em>n</em>)</span></p><p>有兴趣的读者可以自己动手亲自写一写~</p>]]></content>
    
    
    <categories>
      
      <category>算法题(C++)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>快速幂</tag>
      
      <tag>矩阵</tag>
      
      <tag>最优时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大连续子序列求和</title>
    <link href="/2025/07/02/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/"/>
    <url>/2025/07/02/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="最大连续子序列求和">最大连续子序列求和</h2><p>题目：</p><blockquote><p>给你一个整数列，<spanclass="math inline"><em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, <em>A</em><sub>3</sub>, ⋯, <em>A</em><sub><em>n</em></sub></span>，在其中找到一个连续的子链<spanclass="math inline"><em>A</em><sub><em>i</em></sub>, <em>A</em><sub><em>i</em> + 1</sub>, ⋯, <em>A</em><sub><em>j</em></sub>(1 ≤ <em>i</em> ≤ <em>j</em> ≤ <em>N</em>)</span>使得<spanclass="math inline">$\sum_{k=i}^{j}A_k$</span>的值最大，如果所有的数都是负数，则规定最大连续子链和为<spanclass="math inline">0</span></p></blockquote><p>这个其实是非常简单的一道题，随着思维的深入，时间复杂度可以多次降低，比如说，我们肯定可以想到一个时间复杂度为<spanclass="math inline"><em>O</em>(<em>N</em><sup>3</sup>)</span>的算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;start,<span class="hljs-type">int</span> &amp;end)</span></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; size; j++)&#123;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i;k &lt;= j; k++)<br>                count += A[k];<br>            <span class="hljs-keyword">if</span>(count &gt; result)&#123;<br>                result = count;<br>                start = i;<br>                end = j;<br>            &#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个想法比较简单，我就不写注释了。简单分析一下，这里面其实有一个十分浪费的地方，就是每次都需要重新计算<spanclass="math inline">$\sum_{k=i}^{j}A_k$</span>的值，这种做法实际上是没什么必要的，我们完全可以进行预处理，这样时间复杂度降到了<spanclass="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span>，这就是前缀和的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;start,<span class="hljs-type">int</span> &amp;end)</span></span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>)&#123;<br>        start = <span class="hljs-number">0</span>;<br>        end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(result, A[<span class="hljs-number">0</span>]);<span class="hljs-comment">//如果只有一个数，那么就不用想那么多，这个数是正数，就是这个正数，这个数是负数，就是0</span><br>    &#125;<br>    <span class="hljs-type">int</span> *sum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [size<span class="hljs-number">+1</span>];<br>    sum[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; size; i++)<br>        sum[i] = sum[i<span class="hljs-number">-1</span>] + A[i];<span class="hljs-comment">//前缀和，即sum[i]就是A[0]+A[1]+...+A[i]的值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; size; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; size; j++)&#123;<br>            <span class="hljs-keyword">if</span>(result &lt;= (sum[j] - sum[i]))&#123;<br>                start = i;<br>                end = j;<br>                result = (sum[j] - sum[i]);<span class="hljs-comment">//这样，我们只需要用sum[j] - sum[i]就可以表示从i到j中所有元素的和</span><br>            &#125; <br>&#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>笔者这边申明一下，如果返回结果是<spanclass="math inline">0</span>，那就不需要再打出来<code>start</code>和<code>end</code>的值了。具体实现可以写在主函数里，笔者这里就不再赘述了。还有就是<code>sum[j]-sum[i]</code>到底需不需要加括号，这个关于C++运算符号优先级的问题，笔者打算后面专门开一篇来介绍。</p><p>可能有人会对我说：</p><p>主播主播，你的方法确实很强，但是还是太吃时间复杂度了，有没有更简便的方法推荐呢？</p><p>有的兄弟有的</p><p>（理解一下笔者的精神状态）</p><p>好了，正经点，其实还有一种<spanclass="math inline"><em>O</em>(<em>n</em>)</span>的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;start,<span class="hljs-type">int</span> &amp;end)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, result = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    start = <span class="hljs-number">0</span>;<span class="hljs-comment">//把起点都初始化一下</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++)&#123;<span class="hljs-comment">//j往后移，计算这时候的子链和</span><br>        count += A[j];<br>        <span class="hljs-keyword">if</span>(count &gt; result)&#123;<span class="hljs-comment">//如果当下子链和比我之前的结果大，那么就将结果替换为当下的子链和</span><br>            result = count;<br>            start = i;<br>            end = j;<br>&#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count &lt; <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//重点：如果我当下的子链和是小于零的，那么这一段我直接抛掉，将我计算的起始点放到j+1的位置</span><br>            count = <span class="hljs-number">0</span>;<br>            i = j + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个方法，我写了一些备注，不过可能还是有读者没有看懂，我仔细来说一下：<code>i</code>是起点，是我当下计算子列的起始点，然后我去用<code>j</code>来遍历<code>A[]</code>这个数组，将<code>j</code>的结果累计到<code>count</code>中，每一次循环中，对<code>count</code>进行一次检查，如果<code>count</code>小于<code>0</code>，那么直接将<code>i</code>设为<code>j+1</code>，而<code>count</code>归零。</p><p>为什么这样做是正确的？因为任何一个子数列加上一个和小于0的子数列都会使合成的总数列和变小，那么既然如此，我就不计入和小于0的子数列，这一段，在我眼中，属于“亏本”的状态，不管它前置还是后置，我们都不会加上它，简单来说，就是<strong>如果一段连续数列的和是负数，它就不会是最大子序列的开头。</strong></p><p>如果从数学上理解了这点，这道题就迎刃而解了。</p>]]></content>
    
    
    <categories>
      
      <category>算法题(C++)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>最优时间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写在最前面</title>
    <link href="/2025/07/02/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/"/>
    <url>/2025/07/02/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="欢迎你来到牧丛的博客">欢迎你来到牧丛的博客！</h1><p>在正式浏览这个博客的主要内容之前，我希望你能够抽出几分钟的时间来阅读一下这篇文章，或许能够节约你的一部分时间。</p><p>其实笔者在2025年2月份期间，就开始着手搭建自己的博客，当时使用的是matery主题，当时也更新了一些文章，但是一直存在一些格式上不适配的现象，后来在朋友的推荐下选择了fluid的主题。但是交大大一下的课程堪称恐怖，笔者拼劲全力，实在没有办法在保证课内学习质量的情况下持续更新博客，无奈只能停更。现在已是暑假，笔者决定重整旗鼓，重新开始博客的更新。下面是我2025年年初写的前言（略有修改）：</p><p>首先，我想先简单介绍一下有关我博客名字的一些事情。在网址和Github那里，你可以看到我注册的名称是“MYCDherder”，而进入博客后的自我介绍中，会告诉你我的昵称叫“牧丛”，这是我个人习惯所导致的。我是个不怎么会起名字的人，我几乎所有的账户，倘若可以用中文表示，那就一律起名为“牧丛”，而若是需要英文，我一般就会使用“MYCD”。但是由于“MYCD”的名字过短，不能通过Github的名称审核，我只好将两个名字融合起来，“牧丛”没有直接对应的英文单词，我就取了其中的“牧”字，将其翻译为“herder”，“放牧的人”，两者一结合，问题就迎刃而解了。</p><p>再说说笔者，笔者目前是一名上海交通大学的本科生，就读于信息工程专业。在初高中的学习生活中，笔者一直算不上一个出色的学生，也常常被周围巨佬们的天才表现所震撼。在大学的生活中，笔者也往往比较迟钝，很多消息往往知道得比别人慢，产生了一定的信息差。像个人博客这种东西，也是几个月前，笔者发现一个高中同学已经创建了属于自己的博客时才了解到的。</p><p>当然，笔者创立这个博客，并不是为了盲目地跟风。笔者初入大学，对于大学的学习生活，依然没有能够找到一条稳定而高效的路径。显而易见，初高中以熟练度为主的应试方法必然不会符合大学的教育模式，单纯的高分也不是中国本科教育的目的。笔者建立这个博客，其实也是对自己本科学习方法的一种探索。当然，不同于毫无意义的胡乱尝试，创建并运营博客有着一些明显的好处：</p><p>第一，博客的运营需要持续的更新，持续的更新就需要持续的学习与思考，对于自己博客的运营其实也是一种自我的督促。</p><p>第二，更新博客的过程其实也是“费曼学习法”，博客更新的内容是公开的，实质上就是将笔者所学的知识用自己的语言，以通俗易懂的方式教授给别人。在这个过程中，笔者对于知识的理解也会更加透彻。</p><p>当然，创立的博客的好处当然不止这些，但限于篇幅原因，笔者不再继续探讨。其实，笔者更多是想把这个博客做成一个类似于学习笔记的东西，当然，这并不意味着笔者会呆板地去照抄教材。笔者希望的，是能够在这些基础学科中找到一些大家忽略的细节，进行一些深度的思考。</p><p>除了单纯的巩固细节之外，笔者还希望能够对于一些现有的模型进行自己的思考和阐释。当然，这些思考不一定是笔者率先提出来的，笔者所表述出来的语言也不一定精准，肯定会出现许多的瑕疵，但是笔者认为这个过程对于一个求学者来说是必要的。</p><p>在这个过程中，笔者可能会有一些想到一半就无法继续下去的想法，到时候可能会单独开一个列表，欢迎大家和笔者一起思考和讨论。</p><p>最后，笔者第一次创建并且尝试运营博客，可能会出现很多的错误和疏漏，如果读者愿意反馈给我，笔者将不胜感激。</p><p>最后的最后，非常感谢大家能够读完这篇文章，愿我们一起学习，一起进步！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
